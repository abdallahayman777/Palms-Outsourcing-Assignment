<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team API Keys & Proxy Pools - Test Plan</title>
    <style>
        @page {
            margin: 2cm;
            size: A4;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.65;
            color: #2d3436;
            max-width: 210mm;
            margin: 0 auto;
            padding: 20px;
            background: white;
        }
        
        .header {
            border-bottom: 2px solid #0984e3;
            padding-bottom: 15px;
            margin-bottom: 25px;
        }
        
        h1 {
            color: #2d3436;
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .subtitle {
            color: #636e72;
            font-size: 13px;
        }
        
        h2 {
            color: #2d3436;
            font-size: 18px;
            border-bottom: 1px solid #dfe6e9;
            padding-bottom: 8px;
            margin-top: 25px;
            margin-bottom: 12px;
        }
        
        h3 {
            color: #2d3436;
            font-size: 15px;
            margin-top: 18px;
            margin-bottom: 8px;
        }
        
        .section {
            margin-bottom: 20px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 12px 0;
            font-size: 12.5px;
        }
        
        th {
            background-color: #74b9ff;
            color: #2d3436;
            padding: 10px;
            text-align: left;
            font-weight: 600;
            border: 1px solid #a29bfe;
        }
        
        td {
            padding: 8px 10px;
            border: 1px solid #dfe6e9;
            vertical-align: top;
        }
        
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        .note-box {
            background-color: #fff3cd;
            border-left: 3px solid #ffc107;
            padding: 12px;
            margin: 12px 0;
            font-size: 13px;
        }
        
        ul {
            margin: 8px 0;
            padding-left: 22px;
        }
        
        li {
            margin: 6px 0;
            font-size: 13px;
        }
        
        code {
            background-color: #f1f3f5;
            padding: 2px 5px;
            border-radius: 2px;
            font-family: 'Courier New', monospace;
            font-size: 11.5px;
        }
        
        .code-block {
            background-color: #2d3436;
            color: #dfe6e9;
            padding: 12px;
            border-radius: 3px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 11.5px;
            margin: 12px 0;
            line-height: 1.5;
        }
        
        .flow-box {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            text-align: center;
        }
        
        .flow-text {
            font-size: 13px;
            color: #1565c0;
            font-weight: 500;
        }
        
        @media print {
            body {
                padding: 0;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Test Plan: Team API Keys & Proxy Pools</h1>
        <div class="subtitle">QA approach for the new API keys feature</div>
    </div>

    <div class="section">
        <h2>1. Test Plan </h2>
        
        <h3>Core Features that Must Pass</h3>
        <table>
            <tr>
                <th style="width: 18%;">Feature</th>
                <th style="width: 38%;">What it does</th>
                <th style="width: 44%;">What to check</th>
            </tr>
            <tr>
                <td><strong>Create a key</strong></td>
                <td>User types a label, selects a product (Residential, Premium, Dedicated), and picks an environment (dev/stage/prod)</td>
                <td>API returns 201, key is masked (only shows last 4 chars), key is stored in the DB, UI shows it instantly</td>
            </tr>
            <tr>
                <td><strong>View a key</strong></td>
                <td>Shows label, assigned products, environment, and rate‑limit numbers</td>
                <td>Full secret is never shown; UI displays label & masked key</td>
            </tr>
            <tr>
                <td><strong>Edit a key</strong></td>
                <td>Change label, add/remove product assignments, tweak rate‑limit caps</td>
                <td>PATCH works, DB updates, UI reflects new values right away</td>
            </tr>
            <tr>
                <td><strong>Revoke a key</strong></td>
                <td>Stops the key from being usable</td>
                <td>DELETE returns 204, subsequent calls to the proxy return 401/403 within 5 s</td>
            </tr>
            <tr>
                <td><strong>Bulk actions</strong></td>
                <td>Create/revoke 10k+ keys in one request</td>
                <td>Operation finishes in < 90s, no race conditions, UI updates for all affected keys</td>
            </tr>
            <tr>
                <td><strong>Logs</strong></td>
                <td>Every request made with a key is recorded (time, status, IP, country)</td>
                <td>Logs show correct counts, last request details; filtering by key works; no performance hit even with 150k keys</td>
            </tr>
            <tr>
                <td><strong>Environment rules</strong></td>
                <td>dev → low limits, no IP whitelist. stage/prod → higher limits, IP whitelist enforced</td>
                <td>A dev key used on prod should be rejected; IP whitelist is enforced for prod keys</td>
            </tr>
            <tr>
                <td><strong>Proxy routing</strong></td>
                <td>Requests are routed to the pool that the key was assigned to</td>
                <td>If a key has multiple assignments, the header overrides the default pool</td>
            </tr>
        </table>

        <h3>Core Test Cases</h3>
        <p><strong>UI:</strong></p>
        <ul>
            <li>Create key with label/assignment; verify instant list update, pagination/search/filtering works with 100+ keys</li>
            <li>Bulk revoke 1k keys; confirm UI reflects changes, no UI jank on large datasets</li>
            <li>View logs: Filter by key, verify real-time updates after simulated requests</li>
        </ul>

        <p><strong>API:</strong></p>
        <ul>
            <li><code>POST /api-keys</code>: Returns 201 with masked key; assign to products/envs</li>
            <li><code>GET /api-keys/{id}</code>: Returns details (no full key); pagination handles 150k with correct counts</li>
            <li><code>DELETE /api-keys/{id}</code>: 204 response, subsequent gateway calls fail</li>
            <li><code>PATCH /api-keys/{id}</code>: Update label/assignment/rate limits; validate changes propagate</li>
        </ul>

        <p><strong>Data:</strong></p>
        <ul>
            <li>DB integrity: Query backend for key count/assignments post-CRUD; ensure no orphans after revocation</li>
            <li>Logs accuracy: Simulate 1k requests via key, verify counters/IP/country match; reset on billing cycle</li>
            <li>Scale: Seed 150k keys, test query performance (P95 <500ms), concurrent creates (no races)</li>
        </ul>

        <h3>Exploratory Angles (Proxies/Rate Limits/Abuse)</h3>
        <ul>
            <li><strong>Proxies:</strong> Test pool routing edge cases (e.g., key assigned to multiple pools—header overrides default); geo-leakage (wrong country IP); sticky sessions for Dedicated</li>
            <li><strong>Rate Limits:</strong> Burst traffic exceeding limits (e.g., 1001 req/s on prod key → 429 with Retry-After); cross-env abuse (use dev key in prod → rejection)</li>
            <li><strong>Abuse:</strong> Brute-force key guessing (rate-limit API); concurrent revokes during active use; IP whitelist bypass attempts (spoofed IPs); high-volume logs (1M+ entries/key) for overflow/injection</li>
            <li><strong>Usability:</strong> Multi-user concurrent edits (optimistic locking); error messaging clarity on failures; accessibility (screen reader on masked keys)</li>
        </ul>

        <div class="flow-box">
            <div style="font-weight: 600; margin-bottom: 8px;">System Flow (how I understand it):</div>
            <div class="flow-text">User Creates API Key → Assigns to Proxy Pool(s) → Key Used in Request → Gateway Routes to Pool → Proxy Request Executed → Usage Logged</div>
            <div style="margin-top: 8px; font-size: 12px; color: #555;">Environment rules & rate limits enforced at gateway | IP whitelist checked before routing</div>
        </div>
    </div>

    <div class="section">
        <h2>2. Automation Prioritization (1 day + 2 QAs)</h2>
        
        <p>Given the tight timeline, I'd focus on automating the critical paths first—stuff that covers the main user flows and high-risk areas like revocation and scale. With me + 1 senior QA + 1 junior QA, we can probably knock out ~50% automation coverage (5-6 cases) on day 1.</p>
        
        <p><strong>Framework choice:</strong> Cypress for UI (I've used it a lot and it's reliable), Postman/Newman for API, and SQLAlchemy for data checks. I'd own the complex stuff—scale tests, concurrency checks, and code reviews. Senior QA can handle API integrations, and I'll get the junior QA started on simpler UI scripts with some guidance.</p>

        <h3>What to automate first & why</h3>
        
        <table>
            <tr>
                <th style="width: 35%;">Test</th>
                <th style="width: 12%;">Auto?</th>
                <th style="width: 38%;">Reason</th>
                <th style="width: 15%;">Who</th>
            </tr>
            <tr style="background-color: #d4edda;">
                <td>UI: Create single key</td>
                <td><strong>Yes</strong></td>
                <td>High-frequency action, quick to script, catches regressions early</td>
                <td>Junior (I review)</td>
            </tr>
            <tr style="background-color: #d4edda;">
                <td>UI: Bulk create (10k+ keys)</td>
                <td><strong>Yes</strong></td>
                <td>High-scale risk, critical for enterprise users</td>
                <td>Me (complex)</td>
            </tr>
            <tr>
                <td>UI: Bulk revoke</td>
                <td>No</td>
                <td>Manual first to validate UX, automate later if needed</td>
                <td>Manual</td>
            </tr>
            <tr>
                <td>UI: View/filter logs</td>
                <td>No</td>
                <td>Good for exploratory first, automate in future sprints</td>
                <td>Manual</td>
            </tr>
            <tr style="background-color: #d4edda;">
                <td>API: POST /api-keys</td>
                <td><strong>Yes</strong></td>
                <td>Core creation, easy to parameterize, high ROI</td>
                <td>Senior QA</td>
            </tr>
            <tr style="background-color: #d4edda;">
                <td>API: GET /api-keys</td>
                <td><strong>Yes</strong></td>
                <td>Scale-critical (150k keys), verifies pagination</td>
                <td>Me (scale setup)</td>
            </tr>
            <tr style="background-color: #d4edda;">
                <td>API: PATCH /api-keys/{id}</td>
                <td><strong>Yes</strong></td>
                <td>Ensures updates propagate, covers security controls</td>
                <td>Senior QA</td>
            </tr>
            <tr style="background-color: #d4edda;">
                <td>API: DELETE /api-keys/{id}</td>
                <td><strong>Yes</strong></td>
                <td>Critical security—revocation must be immediate</td>
                <td>Me (high risk)</td>
            </tr>
            <tr>
                <td>Data: DB integrity</td>
                <td>No</td>
                <td>Better as manual queries first, automate for CI later</td>
                <td>Manual</td>
            </tr>
            <tr>
                <td>Data: Logs accuracy</td>
                <td>No</td>
                <td>Time-sensitive (billing), high effort for low initial gain</td>
                <td>Manual</td>
            </tr>
            <tr>
                <td>Data: Concurrent operations</td>
                <td>Partial</td>
                <td>Hard to automate reliably, use Locust for load testing</td>
                <td>Exploratory</td>
            </tr>
        </table>

        <div class="note-box">
            <strong>Summary:</strong> First 6 automations are UI1, UI2, API1-4. Focus on API-heavy flows (faster, less flaky) covering ~80% of risks. Morning: planning/setup, parallel scripting during the day, afternoon: test runs & reviews. This leaves time for manual exploratory testing on proxies/abuse scenarios. If we run short on time, we'll drop UI2.
        </div>
    </div>

    <div class="section">
        <h2>3. CI Integration (Cypress + GitHub Actions)</h2>
        
        <p>I've wired up Cypress with GitHub Actions before and it's pretty straightforward. Here's how I'd set it up:</p>

        <h3>Folder structure</h3>
        <div class="code-block">project-root/
├── cypress/
│   ├── e2e/                   // test files like createKey.cy.js
│   ├── fixtures/              // mock data
│   ├── support/               // custom commands (login, DB seeding)
│   └── cypress.config.js
├── .github/workflows/
│   └── ci-tests.yml
├── package.json
└── README.md</div>

        <p>Running locally is just <code>npx cypress run</code></p>

        <h3>CI Jobs (pseudo-YAML)</h3>
        
        <p><strong>Job 1: Smoke tests</strong></p>
        <div class="code-block">name: CI Tests
on: [push, pull_request]

jobs:
  smoke:
    runs-on: ubuntu-latest
    steps:
      - checkout code
      - setup node v20
      - npm install
      - npx cypress run --spec "cypress/e2e/smoke/*" --env baseUrl=$TEST_URL
      - upload videos/screenshots on failure</div>

        <p><strong>Job 2: Full E2E (runs only if smoke passes)</strong></p>
        <div class="code-block">  full-e2e:
    needs: smoke
    runs-on: ubuntu-latest
    steps:
      - checkout code
      - setup node
      - npm install
      - seed DB with 150k keys
      - npx cypress run --browser chrome --parallel --record --key $CYPRESS_KEY
      - generate & upload Mochawesome reports</div>
    </div>

    <div class="section">
        <h2>4. QA Metrics</h2>
        
        <p><strong>1. Core Flow Pass Rate</strong> (create → assign → use → revoke)<br>
        Target: ≥ 95%. If it drops below 90%, we don't deploy. Main user journey needs to be solid.</p>

        <p><strong>2. Flaky Test Rate</strong><br>
        Target: < 5%. Flaky tests kill trust fast, so anything above 5% gets quarantined and fixed or deleted immediately.</p>

        <p><strong>3. Dashboard Regression Rate</strong> (new failures after changes)<br>
        Target: < 2%. A spike means something big broke (like pagination with 100k keys) and we need to fix it before merging.</p>
    </div>

    <div class="section">
        <h2>5. Environment Handling</h2>

        <h3>Test Data Strategy</h3>
        <ul>
            <li><strong>Dev:</strong> Fake scripted data—quick-generated keys, small proxy pools (10-100 IPs). Automation hooks spin it up fast.</li>
            <li><strong>Stage:</strong> Prod-like data (50k keys from snapshots or generators). Cycle proxies regularly to catch scale issues.</li>
            <li><strong>Prod:</strong> Hands-off—monitoring, canary releases, low-risk flagged checks only.</li>
        </ul>

        <h3>Config & Secrets</h3>
        <ul>
            <li>Keep configs (rate limits, whitelists) in AWS Secrets Manager—inject during builds, never hardcode</li>
            <li>Rotate secrets (DB creds, keys) every 90 days, monitor access logs</li>
        </ul>

        <h3>Key Risks per Environment</h3>
        <ul>
            <li><strong>Dev:</strong> Too-loose controls → test data leaks. Fix: mocks + role-based access</li>
            <li><strong>Stage:</strong> Heavy loads → crashes. Fix: add limits & alerts</li>
            <li><strong>Prod:</strong> Outages, key leaks. Fix: gradual rollouts, monitoring (Datadog), easy rollbacks</li>
        </ul>
    </div>

    <div style="text-align: center; margin-top: 30px; padding-top: 15px; border-top: 1px solid #ddd; color: #636e72; font-size: 11px;">
        Test Plan - Team API Keys & Proxy Pools
    </div>
</body>
</html>